"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "../node_modules/next/dist/shared/lib/router/router.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/router.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"../node_modules/@swc/helpers/esm/_async_to_generator.js\");\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"../node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"../node_modules/@swc/helpers/esm/_create_class.js\");\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"../node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"../node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"../node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _ts_generator = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"../node_modules/@swc/helpers/esm/_ts_generator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default() {\n        return Router;\n    },\n    matchesMiddleware: function matchesMiddleware1() {\n        return matchesMiddleware;\n    },\n    createKey: function createKey1() {\n        return createKey;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"../node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"../node_modules/next/dist/client/script.js\");\nvar _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"../node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"../node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"../node_modules/next/dist/shared/lib/utils.js\");\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _resolverewrites = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?36cb\"));\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"../node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"../node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"../node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"../node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"../node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"../node_modules/next/dist/client/add-locale.js\");\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"../node_modules/next/dist/client/remove-locale.js\");\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"../node_modules/next/dist/client/remove-base-path.js\");\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"../node_modules/next/dist/client/add-base-path.js\");\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"../node_modules/next/dist/client/has-base-path.js\");\nvar _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"../node_modules/next/dist/client/resolve-href.js\");\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"../node_modules/next/dist/lib/is-api-route.js\");\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"../node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"../node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"../node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"../node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator._(function(options) {\n        var matchers, _ref, asPathname, cleanedAs, asWithBasePathAndLocale;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        Promise.resolve(options.router.pageLoader.getMiddleware())\n                    ];\n                case 1:\n                    matchers = _state.sent();\n                    if (!matchers) return [\n                        2,\n                        false\n                    ];\n                    _ref = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref.pathname;\n                    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n                    cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n                    asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n                    // Check only path match on client. Matching \"has\" should be done on server\n                    // where we can access more info such as headers, HttpOnly cookie, etc.\n                    return [\n                        2,\n                        matchers.some(function(m) {\n                            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n                        })\n                    ];\n            }\n        });\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(router, url, true), 2), resolvedHref = _ref[0], resolvedAs = _ref[1];\n    var origin = (0, _utils.getLocationOrigin)();\n    var hrefWasAbsolute = resolvedHref.startsWith(origin);\n    var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    var nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    var matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || undefined) {\n            var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            });\n            var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then(function(param) {\n                var _param = _sliced_to_array._(param, 2), pages = _param[0], _param_ = _param[1], rewrites = _param_.__rewrites;\n                var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) { var result; } else if (!pages.includes(fsPathname)) {\n                    var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref: resolvedHref\n                };\n            });\n        }\n        var src = (0, _parsepath.parsePath)(source);\n        var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n            nextConfig: nextConfig,\n            parseData: true\n        })), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            var src1 = (0, _parsepath.parsePath)(redirectTarget);\n            var pathname1 = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src1.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            })), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname1 + src1.query + src1.hash,\n                newUrl: \"\" + pathname1 + src1.query + src1.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n    _withMiddlewareEffects = _async_to_generator._(function(options) {\n        var matches, data, effect, e;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        matchesMiddleware(options)\n                    ];\n                case 1:\n                    matches = _state.sent();\n                    if (!matches || !options.fetchData) {\n                        return [\n                            2,\n                            null\n                        ];\n                    }\n                    _state.label = 2;\n                case 2:\n                    _state.trys.push([\n                        2,\n                        5,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        options.fetchData()\n                    ];\n                case 3:\n                    data = _state.sent();\n                    return [\n                        4,\n                        getMiddlewareData(data.dataHref, data.response, options)\n                    ];\n                case 4:\n                    effect = _state.sent();\n                    return [\n                        2,\n                        {\n                            dataHref: data.dataHref,\n                            json: data.json,\n                            response: data.response,\n                            text: data.text,\n                            cacheKey: data.cacheKey,\n                            effect: effect\n                        }\n                    ];\n                case 5:\n                    e = _state.sent();\n                    /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return [\n                        2,\n                        null\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then(function(response) {\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    var dataHref = param.dataHref, inflightCache = param.inflightCache, isPrefetch = param.isPrefetch, hasMiddleware = param.hasMiddleware, isServerRender = param.isServerRender, parseJSON = param.parseJSON, persistCache = param.persistCache, isBackground = param.isBackground, unstable_skipClientCache = param.unstable_skipClientCache;\n    var _ref = new URL(dataHref, window.location.href), cacheKey = _ref.href;\n    var _params_method;\n    var getData = function(params) {\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then(function(response) {\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref: dataHref,\n                    response: response,\n                    text: \"\",\n                    json: {},\n                    cacheKey: cacheKey\n                };\n            }\n            return response.text().then(function(text) {\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref: dataHref,\n                            response: response,\n                            text: text,\n                            json: {},\n                            cacheKey: cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref: dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response: response,\n                                text: text,\n                                cacheKey: cacheKey\n                            };\n                        }\n                    }\n                    var error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref: dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response: response,\n                    text: text,\n                    cacheKey: cacheKey\n                };\n            });\n        }).then(function(data) {\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        })[\"catch\"](function(err) {\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then(function(data) {\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    var url = param.url, router = param.router;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nvar getCancelledHandler = function(param) {\n    var route = param.route, router = param.router;\n    var cancelled = false;\n    var cancel = router.clc = function() {\n        cancelled = true;\n    };\n    var handleCancelled = function() {\n        if (cancelled) {\n            var error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname, query, as, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _class_call_check._(this, Router);\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = function(e) {\n            var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n            _this.isFirstPopStateEvent = false;\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var _$pathname = _this.pathname, _$query = _this.query;\n                _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(_$pathname),\n                    query: _$query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, _$as = state.as, options = state.options, key = state.key;\n            if (false) { var v; }\n            _this._key = key;\n            var _$pathname1 = (0, _parserelativeurl.parseRelativeUrl)(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && _$as === (0, _addbasepath.addBasePath)(_this.asPath) && _$pathname1 === (0, _addbasepath.addBasePath)(_this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change(\"replaceState\", url, _$as, Object.assign({}, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        var route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            var BloomFilter = (__webpack_require__(/*! ../../lib/bloom-filter */ \"../node_modules/next/dist/shared/lib/bloom-filter.js\").BloomFilter);\n            var staticFilterData = {\"numItems\":2,\"errorRate\":0.0001,\"numBits\":39,\"numHashes\":14,\"bitArray\":[0,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0]};\n            var dynamicFilterData = {\"numItems\":0,\"errorRate\":0.0001,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s[\"import\"](staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d[\"import\"](dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route: route,\n            pathname: pathname,\n            query: query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback: isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options = {\n                    locale: locale\n                };\n                var asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale: locale,\n                    asPath: asPath\n                }).then(function(matches) {\n                    options._shouldResolveHref = as !== pathname;\n                    _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query: query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _create_class._(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Go forward in history\n   */ key: \"forward\",\n            value: function forward() {\n                window.history.forward();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as, options) {\n                if (options === void 0) options = {};\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"pushState\", url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as, options) {\n                if (options === void 0) options = {};\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"replaceState\", url, as, options);\n            }\n        },\n        {\n            key: \"_bfl\",\n            value: function _bfl(as, resolvedAs, locale, skipNavigate) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var matchesBflStatic, matchesBflDynamic, _i, _iter, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i1, _iter1, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n                    return _ts_generator._(this, function(_state) {\n                        if (true) {\n                            matchesBflStatic = false;\n                            matchesBflDynamic = false;\n                            for(_i = 0, _iter = [\n                                as,\n                                resolvedAs\n                            ]; _i < _iter.length; _i++){\n                                curAs = _iter[_i];\n                                if (curAs) {\n                                    asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                                    asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || _this.locale));\n                                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(_this.asPath, \"http://n\").pathname)) {\n                                        ;\n                                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = _this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = _this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                                        for(_i1 = 0, _iter1 = [\n                                            asNoSlash,\n                                            asNoSlashLocale\n                                        ]; _i1 < _iter1.length; _i1++){\n                                            normalizedAS = _iter1[_i1];\n                                            // if any sub-path of as matches a dynamic filter path\n                                            // it should be hard navigated\n                                            curAsParts = normalizedAS.split(\"/\");\n                                            for(i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                                ;\n                                                currentPart = curAsParts.slice(0, i).join(\"/\");\n                                                if (currentPart && ((_this__bfl_d = _this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                                    matchesBflDynamic = true;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        // if the client router filter is matched then we trigger\n                                        // a hard navigation\n                                        if (matchesBflStatic || matchesBflDynamic) {\n                                            if (skipNavigate) {\n                                                return [\n                                                    2,\n                                                    true\n                                                ];\n                                            }\n                                            handleHardNavigation({\n                                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || _this.locale, _this.defaultLocale)),\n                                                router: _this\n                                            });\n                                            return [\n                                                2,\n                                                new Promise(function() {})\n                                            ];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            2,\n                            false\n                        ];\n                    });\n                })();\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options_shallow, shallow, _options_scroll, scroll, routeProps, cleanedAs, localeChange, err, parsed, pathname, query, pages, rewrites, ref, ref1, err1, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, _tmp, rewritesResult, routeMatch, parsedAs1, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, routeRegex1, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs, newUrl, newAs, notFoundRoute, _, _routeInfo_route, isValidShallowRoute, _options_scroll1, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1, err2, canSkipUpdating, e, hashRegex, err3;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!(0, _islocalurl.isLocalURL)(url)) {\n                                    handleHardNavigation({\n                                        url: url,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                // WARNING: `_h` is an internal option for handing Next.js client-side\n                                // hydration. Your app should _never_ use this property. It may change at\n                                // any time without notice.\n                                isQueryUpdating = options._h === 1;\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    2\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, undefined, options.locale)\n                                ];\n                            case 1:\n                                _state.sent();\n                                _state.label = 2;\n                            case 2:\n                                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                                nextState = _object_spread._({}, _this.state);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                // or a navigation has occurred\n                                readyStateChange = _this.isReady !== true;\n                                _this.isReady = true;\n                                isSsr = _this.isSsr;\n                                if (!isQueryUpdating) {\n                                    _this.isSsr = false;\n                                }\n                                // if a route transition is already in progress before\n                                // the query updating is triggered ignore query updating\n                                if (isQueryUpdating && _this.clc) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                prevLocale = nextState.locale;\n                                if (false) {}\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark(\"routeChange\");\n                                }\n                                _options_shallow = options.shallow, shallow = _options_shallow === void 0 ? false : _options_shallow, _options_scroll = options.scroll, scroll = _options_scroll === void 0 ? true : _options_scroll;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (_this._inFlightRoute && _this.clc) {\n                                    if (!isSsr) {\n                                        Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                                    }\n                                    _this.clc();\n                                    _this.clc = null;\n                                }\n                                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, _this.defaultLocale));\n                                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                                _this._inFlightRoute = as;\n                                localeChange = prevLocale !== nextState.locale;\n                                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) return [\n                                    3,\n                                    7\n                                ];\n                                nextState.asPath = cleanedAs;\n                                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                _this.changeState(method, url, as, _object_spread_props._(_object_spread._({}, options), {\n                                    scroll: false\n                                }));\n                                if (scroll) {\n                                    _this.scrollToHash(cleanedAs);\n                                }\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(nextState, _this.components[nextState.route], null)\n                                ];\n                            case 4:\n                                _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                err = _state.sent();\n                                if ((0, _iserror[\"default\"])(err) && err.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                                }\n                                throw err;\n                            case 6:\n                                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 7:\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                _state.label = 8;\n                            case 8:\n                                _state.trys.push([\n                                    8,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader.getPageList(),\n                                        (0, _routeloader.getClientBuildManifest)(),\n                                        _this.pageLoader.getMiddleware()\n                                    ])\n                                ];\n                            case 9:\n                                ref = _sliced_to_array._.apply(void 0, [\n                                    _state.sent(),\n                                    2\n                                ]), pages = ref[0], ref1 = ref[1], rewrites = ref1.__rewrites, ref1, ref;\n                                return [\n                                    3,\n                                    11\n                                ];\n                            case 10:\n                                err1 = _state.sent();\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                handleHardNavigation({\n                                    url: as,\n                                    router: _this\n                                });\n                                return [\n                                    2,\n                                    false\n                                ];\n                            case 11:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = \"replaceState\";\n                                }\n                                // we need to resolve the as value using rewrites for dynamic SSG\n                                // pages to allow building the data URL correctly\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                                // if we detected the path as app route during prefetching\n                                // trigger hard navigation\n                                if ((_this_components_pathname = _this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n                                _tmp = !options.shallow;\n                                if (!_tmp) return [\n                                    3,\n                                    13\n                                ];\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: as,\n                                        locale: nextState.locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 12:\n                                _tmp = _state.sent();\n                                _state.label = 13;\n                            case 13:\n                                isMiddlewareMatch = _tmp;\n                                if (isQueryUpdating && isMiddlewareMatch) {\n                                    shouldResolveHref = false;\n                                }\n                                if (shouldResolveHref && pathname !== \"/_error\") {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                                            if (!isMiddlewareMatch) {\n                                                url = (0, _formaturl.formatWithValidation)(parsed);\n                                            }\n                                        }\n                                    }\n                                }\n                                if (!(0, _islocalurl.isLocalURL)(as)) {\n                                    if (true) {\n                                        throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                                    }\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                routeMatch = false;\n                                if ((0, _isdynamic.isDynamicRoute)(route)) {\n                                    parsedAs1 = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                                    asPathname = parsedAs1.pathname;\n                                    routeRegex = (0, _routeregex.getRouteRegex)(route);\n                                    routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                                    shouldInterpolate = route === asPathname;\n                                    interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n                                    if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                                        missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                            return !query[param] && !routeRegex.groups[param].optional;\n                                        });\n                                        if (missingParams.length > 0 && !isMiddlewareMatch) {\n                                            if (true) {\n                                                console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                                            }\n                                            throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                                        }\n                                    } else if (shouldInterpolate) {\n                                        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs1, {\n                                            pathname: interpolatedAs.result,\n                                            query: (0, _omit.omit)(query, interpolatedAs.params)\n                                        }));\n                                    } else {\n                                        // Merge params into `query`, overwriting any specified in search\n                                        Object.assign(query, routeMatch);\n                                    }\n                                }\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeStart\", as, routeProps);\n                                }\n                                isErrorRoute = _this.pathname === \"/404\" || _this.pathname === \"/_error\";\n                                _state.label = 14;\n                            case 14:\n                                _state.trys.push([\n                                    14,\n                                    35,\n                                    ,\n                                    36\n                                ]);\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: route,\n                                        pathname: pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: routeProps,\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        hasMiddleware: isMiddlewareMatch,\n                                        unstable_skipClientCache: options.unstable_skipClientCache,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                                        isMiddlewareRewrite: isMiddlewareRewrite\n                                    })\n                                ];\n                            case 15:\n                                routeInfo = _state.sent();\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    17\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale)\n                                ];\n                            case 16:\n                                _state.sent();\n                                _state.label = 17;\n                            case 17:\n                                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                                    pathname = routeInfo.route || route;\n                                    route = pathname;\n                                    if (!routeProps.shallow) {\n                                        query = Object.assign({}, routeInfo.query || {}, query);\n                                    }\n                                    cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                                        Object.keys(routeMatch).forEach(function(key) {\n                                            if (routeMatch && query[key] === routeMatch[key]) {\n                                                delete query[key];\n                                            }\n                                        });\n                                    }\n                                    if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                                        prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                                        rewriteAs = prefixedAs;\n                                        if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                                            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                                        }\n                                        if (false) {}\n                                        routeRegex1 = (0, _routeregex.getRouteRegex)(pathname);\n                                        curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                                        if (curRouteMatch) {\n                                            Object.assign(query, curRouteMatch);\n                                        }\n                                    }\n                                }\n                                // If the routeInfo brings a redirect we simply apply it.\n                                if (\"type\" in routeInfo) {\n                                    if (routeInfo.type === \"redirect-internal\") {\n                                        return [\n                                            2,\n                                            _this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n                                        ];\n                                    } else {\n                                        handleHardNavigation({\n                                            url: routeInfo.destination,\n                                            router: _this\n                                        });\n                                        return [\n                                            2,\n                                            new Promise(function() {})\n                                        ];\n                                    }\n                                }\n                                component = routeInfo.Component;\n                                if (component && component.unstable_scriptLoader) {\n                                    scripts = [].concat(component.unstable_scriptLoader());\n                                    scripts.forEach(function(script) {\n                                        (0, _script.handleClientScriptLoad)(script.props);\n                                    });\n                                }\n                                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) return [\n                                    3,\n                                    23\n                                ];\n                                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                                    // Use the destination from redirect without adding locale\n                                    options.locale = false;\n                                    destination = routeInfo.props.pageProps.__N_REDIRECT;\n                                    // check if destination is internal (resolves to a page) and attempt\n                                    // client-navigation if it is falling back to hard navigation if\n                                    // it's not\n                                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                                        parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                        _prepareUrlAs = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs.url, newAs = _prepareUrlAs.as;\n                                        return [\n                                            2,\n                                            _this.change(method, newUrl, newAs, options)\n                                        ];\n                                    }\n                                    handleHardNavigation({\n                                        url: destination,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) return [\n                                    3,\n                                    23\n                                ];\n                                _state.label = 18;\n                            case 18:\n                                _state.trys.push([\n                                    18,\n                                    20,\n                                    ,\n                                    21\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/404\")\n                                ];\n                            case 19:\n                                _state.sent();\n                                notFoundRoute = \"/404\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 20:\n                                _ = _state.sent();\n                                notFoundRoute = \"/_error\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 21:\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: notFoundRoute,\n                                        pathname: notFoundRoute,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isNotFound: true\n                                    })\n                                ];\n                            case 22:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on /404\");\n                                }\n                                _state.label = 23;\n                            case 23:\n                                if (isQueryUpdating && _this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                // shallow routing is only allowed for same page URL changes.\n                                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                                shouldScroll = (_options_scroll1 = options.scroll) != null ? _options_scroll1 : !isQueryUpdating && !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                                // the new state that the router gonna set\n                                upcomingRouterState = _object_spread_props._(_object_spread._({}, nextState), {\n                                    route: route,\n                                    pathname: pathname,\n                                    query: query,\n                                    asPath: cleanedAs,\n                                    isFallback: false\n                                });\n                                if (!(isQueryUpdating && isErrorRoute)) return [\n                                    3,\n                                    29\n                                ];\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: _this.pathname,\n                                        pathname: _this.pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback\n                                    })\n                                ];\n                            case 24:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on \" + _this.pathname);\n                                }\n                                if (_this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                _state.label = 25;\n                            case 25:\n                                _state.trys.push([\n                                    25,\n                                    27,\n                                    ,\n                                    28\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 26:\n                                _state.sent();\n                                return [\n                                    3,\n                                    28\n                                ];\n                            case 27:\n                                err2 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err2) && err2.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err2, cleanedAs, routeProps);\n                                }\n                                throw err2;\n                            case 28:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 29:\n                                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                                _this.changeState(method, url, as, options);\n                                // for query updates we can skip it if the state is unchanged and we don't\n                                // need to scroll\n                                // https://github.com/vercel/next.js/issues/37139\n                                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, _this.state);\n                                if (!!canSkipUpdating) return [\n                                    3,\n                                    34\n                                ];\n                                _state.label = 30;\n                            case 30:\n                                _state.trys.push([\n                                    30,\n                                    32,\n                                    ,\n                                    33\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 31:\n                                _state.sent();\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 32:\n                                e = _state.sent();\n                                if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                                else throw e;\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 33:\n                                if (routeInfo.error) {\n                                    if (!isQueryUpdating) {\n                                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                                    }\n                                    throw routeInfo.error;\n                                }\n                                if (false) {}\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                                }\n                                // A hash mark # is the optional last part of a URL\n                                hashRegex = /#.+$/;\n                                if (shouldScroll && hashRegex.test(as)) {\n                                    _this.scrollToHash(as);\n                                }\n                                _state.label = 34;\n                            case 34:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 35:\n                                err3 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err3) && err3.cancelled) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                throw err3;\n                            case 36:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, options) {\n                if (options === void 0) options = {};\n                if (true) {\n                    if (typeof window.history === \"undefined\") {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === \"undefined\") {\n                        console.error(\"Warning: window.history.\" + method + \" is not available\");\n                        return;\n                    }\n                }\n                if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        key: this._key = method !== \"pushState\" ? this._key : createKey()\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/docs/Web/API/History/replaceState\n                    \"\", as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var props, _ref, Component, styleSheets, routeInfo, gipErr, routeInfoErr;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                console.error(err);\n                                if (err.cancelled) {\n                                    // bubble up cancellation errors\n                                    throw err;\n                                }\n                                if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n                                    Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                                    // If we can't load the page it could be one of following reasons\n                                    //  1. Page doesn't exists\n                                    //  2. Page does exist in a different zone\n                                    //  3. Internal error while loading the page\n                                    // So, doing a hard reload is the proper way to deal with this.\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    // Changing the URL doesn't block executing the current code path.\n                                    // So let's throw a cancellation error stop the routing logic.\n                                    throw buildCancellationError();\n                                }\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    7,\n                                    ,\n                                    8\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/_error\")\n                                ];\n                            case 2:\n                                _ref = _state.sent(), Component = _ref.page, styleSheets = _ref.styleSheets;\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (!!routeInfo.props) return [\n                                    3,\n                                    6\n                                ];\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.getInitialProps(Component, {\n                                        err: err,\n                                        pathname: pathname,\n                                        query: query\n                                    })\n                                ];\n                            case 4:\n                                routeInfo.props = _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                gipErr = _state.sent();\n                                console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                                routeInfo.props = {};\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 6:\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 7:\n                                routeInfoErr = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror[\"default\"])(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true)\n                                ];\n                            case 8:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(param) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, _tmp, resolvedRoute, pages, routeInfo, _tmp1, isValidElementType, wasBailedPrefetch, shouldFetchData, _ref, props, cacheKey, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                                /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ route = requestedRoute;\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                existingInfo = _this.components[route];\n                                if (routeProps.shallow && existingInfo && _this.route === route) {\n                                    return [\n                                        2,\n                                        existingInfo\n                                    ];\n                                }\n                                if (hasMiddleware) {\n                                    existingInfo = undefined;\n                                }\n                                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                                isBackground = isQueryUpdating;\n                                fetchNextDataParams = {\n                                    dataHref: _this.pageLoader.getDataHref({\n                                        href: (0, _formaturl.formatWithValidation)({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        skipInterpolation: true,\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale\n                                    }),\n                                    hasMiddleware: true,\n                                    isServerRender: _this.isSsr,\n                                    parseJSON: true,\n                                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                                    persistCache: !isPreview,\n                                    isPrefetch: false,\n                                    unstable_skipClientCache: unstable_skipClientCache,\n                                    isBackground: isBackground\n                                };\n                                if (!(isQueryUpdating && !isMiddlewareRewrite)) return [\n                                    3,\n                                    2\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    4\n                                ];\n                            case 2:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData(fetchNextDataParams);\n                                        },\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale,\n                                        router: _this\n                                    })[\"catch\"](function(err) {\n                                        // we don't hard error during query updating\n                                        // as it's un-necessary and doesn't need to be fatal\n                                        // unless it is a fallback route and the props can't\n                                        // be loaded\n                                        if (isQueryUpdating) {\n                                            return null;\n                                        }\n                                        throw err;\n                                    })\n                                ];\n                            case 3:\n                                _tmp = _state.sent();\n                                _state.label = 4;\n                            case 4:\n                                data = _tmp;\n                                // when rendering error routes we don't apply middleware\n                                // effects\n                                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                                    data.effect = undefined;\n                                }\n                                if (isQueryUpdating) {\n                                    if (!data) {\n                                        data = {\n                                            json: self.__NEXT_DATA__.props\n                                        };\n                                    } else {\n                                        data.json = self.__NEXT_DATA__.props;\n                                    }\n                                }\n                                handleCancelled();\n                                if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                                    return [\n                                        2,\n                                        data.effect\n                                    ];\n                                }\n                                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) return [\n                                    3,\n                                    6\n                                ];\n                                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 5:\n                                pages = _state.sent();\n                                // during query updating the page must match although during\n                                // client-transition a redirect that doesn't match a page\n                                // can be returned and this should trigger a hard navigation\n                                // which is valid for incremental migration\n                                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                                    route = resolvedRoute;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, _this.locales).pathname);\n                                    // Check again the cache with the new destination.\n                                    existingInfo = _this.components[route];\n                                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                                        // If we have a match with the current route due to rewrite,\n                                        // we can copy the existing information to the rewritten one.\n                                        // Then, we return the information along with the matched route.\n                                        return [\n                                            2,\n                                            _object_spread_props._(_object_spread._({}, existingInfo), {\n                                                route: route\n                                            })\n                                        ];\n                                    }\n                                }\n                                _state.label = 6;\n                            case 6:\n                                if ((0, _isapiroute.isAPIRoute)(route)) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _tmp1 = cachedRouteInfo;\n                                if (_tmp1) return [\n                                    3,\n                                    8\n                                ];\n                                return [\n                                    4,\n                                    _this.fetchComponent(route).then(function(res) {\n                                        return {\n                                            Component: res.page,\n                                            styleSheets: res.styleSheets,\n                                            __N_SSG: res.mod.__N_SSG,\n                                            __N_SSP: res.mod.__N_SSP\n                                        };\n                                    })\n                                ];\n                            case 7:\n                                _tmp1 = _state.sent();\n                                _state.label = 8;\n                            case 8:\n                                routeInfo = _tmp1;\n                                if (true) {\n                                    isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"../node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                                    if (!isValidElementType(routeInfo.Component)) {\n                                        throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                                    }\n                                }\n                                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                                // For non-SSG prefetches that bailed before sending data\n                                // we clear the cache to fetch full response\n                                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                                    delete _this.sdc[data.dataHref];\n                                }\n                                return [\n                                    4,\n                                    _this._getData(/*#__PURE__*/ _async_to_generator._(function() {\n                                        var dataHref, fetched, _tmp;\n                                        return _ts_generator._(this, function(_state) {\n                                            switch(_state.label){\n                                                case 0:\n                                                    if (!shouldFetchData) return [\n                                                        3,\n                                                        2\n                                                    ];\n                                                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                                                        return [\n                                                            2,\n                                                            {\n                                                                cacheKey: data.cacheKey,\n                                                                props: data.json\n                                                            }\n                                                        ];\n                                                    }\n                                                    dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                                                        href: (0, _formaturl.formatWithValidation)({\n                                                            pathname: pathname,\n                                                            query: query\n                                                        }),\n                                                        asPath: resolvedAs,\n                                                        locale: locale\n                                                    });\n                                                    return [\n                                                        4,\n                                                        fetchNextData({\n                                                            dataHref: dataHref,\n                                                            isServerRender: _this.isSsr,\n                                                            parseJSON: true,\n                                                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                                                            persistCache: !isPreview,\n                                                            isPrefetch: false,\n                                                            unstable_skipClientCache: unstable_skipClientCache\n                                                        })\n                                                    ];\n                                                case 1:\n                                                    fetched = _state.sent();\n                                                    return [\n                                                        2,\n                                                        {\n                                                            cacheKey: fetched.cacheKey,\n                                                            props: fetched.json || {}\n                                                        }\n                                                    ];\n                                                case 2:\n                                                    _tmp = {\n                                                        headers: {}\n                                                    };\n                                                    return [\n                                                        4,\n                                                        _this.getInitialProps(routeInfo.Component, {\n                                                            pathname: pathname,\n                                                            query: query,\n                                                            asPath: as,\n                                                            locale: locale,\n                                                            locales: _this.locales,\n                                                            defaultLocale: _this.defaultLocale\n                                                        })\n                                                    ];\n                                                case 3:\n                                                    return [\n                                                        2,\n                                                        (_tmp.props = _state.sent(), _tmp)\n                                                    ];\n                                            }\n                                        });\n                                    }))\n                                ];\n                            case 9:\n                                _ref = _state.sent(), props = _ref.props, cacheKey = _ref.cacheKey;\n                                // Only bust the data cache for SSP routes although\n                                // middleware can skip cache per request with\n                                // x-middleware-cache: no-cache as well\n                                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                                    delete _this.sdc[cacheKey];\n                                }\n                                // we kick off a HEAD request in the background\n                                // when a non-prefetch request is made to signal revalidation\n                                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                                props.pageProps = Object.assign({}, props.pageProps);\n                                routeInfo.props = props;\n                                routeInfo.route = route;\n                                routeInfo.query = query;\n                                routeInfo.resolvedAs = resolvedAs;\n                                _this.components[route] = routeInfo;\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 10:\n                                err = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps)\n                                ];\n                            case 11:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(state, data, resetScroll) {\n                this.state = state;\n                return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var _this_asPath_split = _sliced_to_array._(this.asPath.split(\"#\", 2), 2), oldUrlNoHash = _this_asPath_split[0], oldHash = _this_asPath_split[1];\n                var _as_split = _sliced_to_array._(as.split(\"#\", 2), 2), newUrlNoHash = _as_split[0], newHash = _as_split[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var _as_split = _sliced_to_array._(as.split(\"#\", 2), 2), tmp = _as_split[1], hash = tmp === void 0 ? \"\" : tmp;\n                (0, _handlesmoothscroll.handleSmoothScroll)(function() {\n                    // Scroll to top if the hash is just `#` with no value or `#top`\n                    // To mirror browsers\n                    if (hash === \"\" || hash === \"top\") {\n                        window.scrollTo(0, 0);\n                        return;\n                    }\n                    // Decode hash to make non-latin anchor works.\n                    var rawHash = decodeURIComponent(hash);\n                    // First we check if the element by id is found\n                    var idEl = document.getElementById(rawHash);\n                    if (idEl) {\n                        idEl.scrollIntoView();\n                        return;\n                    }\n                    // If there's no element with the id, we check the `name` property\n                    // To mirror browsers\n                    var nameEl = document.getElementsByName(rawHash)[0];\n                    if (nameEl) {\n                        nameEl.scrollIntoView();\n                    }\n                }, {\n                    onlyHashChange: this.onlyAHashChange(as)\n                });\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url, asPath, options) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, ref, rewritesResult, data, _tmp, route;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (asPath === void 0) asPath = url;\n                                if (options === void 0) options = {};\n                                // Prefetch is not supported in development mode because it would trigger on-demand-entries\n                                if (true) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n                                    // No prefetches for bots that render the link since they are typically navigating\n                                    // links via the equivalent of a hard navigation and hence never utilize these\n                                    // prefetches.\n                                    return [\n                                        2\n                                    ];\n                                }\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                urlPathname = parsed.pathname;\n                                pathname = parsed.pathname, query = parsed.query;\n                                originalPathname = pathname;\n                                if (false) {}\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 1:\n                                pages = _state.sent();\n                                resolvedAs = asPath;\n                                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 2:\n                                isMiddlewareMatch = _state.sent();\n                                if (true) return [\n                                    3,\n                                    4\n                                ];\n                                return [\n                                    4,\n                                    (0, _routeloader.getClientBuildManifest)()\n                                ];\n                            case 3:\n                                ref = _state.sent(), rewrites = ref.__rewrites, ref;\n                                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, _this.locale), true), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (rewritesResult.externalDest) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if (!isMiddlewareMatch) {\n                                    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), _this.locale);\n                                }\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                _state.label = 4;\n                            case 4:\n                                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                                    pathname = parsed.pathname;\n                                    parsed.pathname = pathname;\n                                    Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                if (true) return [\n                                    3,\n                                    5\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    7\n                                ];\n                            case 5:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData({\n                                                dataHref: _this.pageLoader.getDataHref({\n                                                    href: (0, _formaturl.formatWithValidation)({\n                                                        pathname: originalPathname,\n                                                        query: query\n                                                    }),\n                                                    skipInterpolation: true,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                hasMiddleware: true,\n                                                isServerRender: _this.isSsr,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true\n                                            });\n                                        },\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 6:\n                                _tmp = _state.sent();\n                                _state.label = 7;\n                            case 7:\n                                data = _tmp;\n                                /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                                    parsed.pathname = data.effect.resolvedHref;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = data.effect.parsedAs.pathname;\n                                    url = (0, _formaturl.formatWithValidation)(parsed);\n                                }\n                                /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                return [\n                                    4,\n                                    _this._bfl(asPath, resolvedAs, options.locale, true)\n                                ];\n                            case 8:\n                                if (_state.sent()) {\n                                    _this.components[urlPathname] = {\n                                        __appRouter: true\n                                    };\n                                }\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader._isSsg(route).then(function(isSsg) {\n                                            return isSsg ? fetchNextData({\n                                                dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                                                    href: url,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                isServerRender: false,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true,\n                                                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                                            }).then(function() {\n                                                return false;\n                                            })[\"catch\"](function() {\n                                                return false;\n                                            }) : false;\n                                        }),\n                                        _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n                                    ])\n                                ];\n                            case 9:\n                                _state.sent();\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var handleCancelled, componentResult, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    3,\n                                    ,\n                                    4\n                                ]);\n                                return [\n                                    4,\n                                    _this.pageLoader.loadPage(route)\n                                ];\n                            case 2:\n                                componentResult = _state.sent();\n                                handleCancelled();\n                                return [\n                                    2,\n                                    componentResult\n                                ];\n                            case 3:\n                                err = _state.sent();\n                                handleCancelled();\n                                throw err;\n                            case 4:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error(\"Loading initial props cancelled\");\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                // Do not cache RSC flight response since it's not a static resource\n                return fetchNextData({\n                    dataHref: dataHref,\n                    isServerRender: true,\n                    parseJSON: false,\n                    inflightCache: this.sdc,\n                    persistCache: false,\n                    isPrefetch: false\n                }).then(function(param) {\n                    var text = param.text;\n                    return {\n                        data: text\n                    };\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var _this_components__app = this.components[\"/_app\"], App = _this_components__app.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils.loadGetInitialProps)(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"route\",\n            get: function get() {\n                return this.state.route;\n            }\n        },\n        {\n            key: \"pathname\",\n            get: function get() {\n                return this.state.pathname;\n            }\n        },\n        {\n            key: \"query\",\n            get: function get() {\n                return this.state.query;\n            }\n        },\n        {\n            key: \"asPath\",\n            get: function get() {\n                return this.state.asPath;\n            }\n        },\n        {\n            key: \"locale\",\n            get: function get() {\n                return this.state.locale;\n            }\n        },\n        {\n            key: \"isFallback\",\n            get: function get() {\n                return this.state.isFallback;\n            }\n        },\n        {\n            key: \"isPreview\",\n            get: function get() {\n                return this.state.isPreview;\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt[\"default\"])(); //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsNEJBQTRCO0FBQ2Y7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBSU47QUFDQSxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVixPQUFPQyxjQUFjLENBQUNRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRyxXQUFTLFNBQVRBO1FBQ0ksT0FBT1M7SUFDWDtJQUNBUixtQkFBbUIsU0FBbkJBO1FBQ0ksT0FBT0E7SUFDWDtJQUNBQyxXQUFXLFNBQVhBO1FBQ0ksT0FBT0E7SUFDWDtBQUNKO0FBQ0EsSUFBTVEsMkJBQTJCQyxtQkFBT0EsQ0FBQyw2R0FBeUM7QUFDbEYsSUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQywrR0FBMEM7QUFDcEYsSUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxpSEFBK0I7QUFDcEUsSUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsc0ZBQThCO0FBQzNELElBQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUF3QjtBQUNoRCxJQUFNSyxXQUFXLFdBQVcsR0FBR0osMEJBQTBCSyxDQUFDLENBQUNOLG1CQUFPQSxDQUFDLHdFQUF1QjtBQUMxRixJQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLG1IQUFvQztBQUN6RSxJQUFNUSx1QkFBdUJSLG1CQUFPQSxDQUFDLHlHQUErQjtBQUNwRSxJQUFNUyxRQUFRLFdBQVcsR0FBR1YseUJBQXlCTyxDQUFDLENBQUNOLG1CQUFPQSxDQUFDLDZEQUFTO0FBQ3hFLElBQU1VLFNBQVNWLG1CQUFPQSxDQUFDLCtEQUFVO0FBQ2pDLElBQU1XLGFBQWFYLG1CQUFP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QUM3RixLQUFLO1lBQzNCOzs7WUFDSXhFLEtBQUFBO2lCQUFKO2dCQUNJLE9BQU8sSUFBSSxDQUFDcUssS0FBSyxDQUFDckssTUFBTTtZQUM1Qjs7O1lBQ0lNLEtBQUFBO2lCQUFKO2dCQUNJLE9BQU8sSUFBSSxDQUFDK0osS0FBSyxDQUFDL0osTUFBTTtZQUM1Qjs7O1lBQ0l1SixLQUFBQTtpQkFBSjtnQkFDSSxPQUFPLElBQUksQ0FBQ1EsS0FBSyxDQUFDUixVQUFVO1lBQ2hDOzs7WUFDSUUsS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUNNLEtBQUssQ0FBQ04sU0FBUztZQUMvQjs7O1dBdG1DRWxOOztBQSt4Q05BLE9BQU9nUSxNQUFNLEdBQUcsQ0FBQyxHQUFHclAsS0FBTXBCLENBQUFBLFVBQU8sS0FFakMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz8xMjgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogbnVsbCxcbiAgICBjcmVhdGVLZXk6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzTWlkZGxld2FyZTtcbiAgICB9LFxuICAgIGNyZWF0ZUtleTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVLZXk7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfcm91dGVsb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbmNvbnN0IF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG5jb25zdCBfZGVub3JtYWxpemVwYWdlcGF0aCA9IHJlcXVpcmUoXCIuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xuY29uc3QgX25vcm1hbGl6ZWxvY2FsZXBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbmNvbnN0IF9yZXNvbHZlcmV3cml0ZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmVsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3Jlc29sdmUtaHJlZlwiKTtcbmNvbnN0IF9pc2FwaXJvdXRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1hcGktcm91dGVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfY29tcGFyZXN0YXRlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBhcmUtc3RhdGVzXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfaXNib3QgPSByZXF1aXJlKFwiLi91dGlscy9pcy1ib3RcIik7XG5jb25zdCBfb21pdCA9IHJlcXVpcmUoXCIuL3V0aWxzL29taXRcIik7XG5jb25zdCBfaW50ZXJwb2xhdGVhcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsXCIpO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoXCJSb3V0ZSBDYW5jZWxsZWRcIiksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKG9wdGlvbnMuYXNQYXRoKTtcbiAgICAvLyByZW1vdmUgYmFzZVBhdGggZmlyc3Qgc2luY2UgcGF0aCBwcmVmaXggaGFzIHRvIGJlIGluIHRoZSBvcmRlciBvZiBgLyR7YmFzZVBhdGh9LyR7bG9jYWxlfWBcbiAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aG5hbWUpIDogYXNQYXRobmFtZTtcbiAgICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSkpO1xuICAgIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gICAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSk9Pm5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpKTtcbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgY29uc3QgaHJlZldhc0Fic29sdXRlID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICBjb25zdCBhc1dhc0Fic29sdXRlID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZldhc0Fic29sdXRlID8gcmVzb2x2ZWRIcmVmIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbigoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNXYXNBYnNvbHV0ZSA/IHByZXBhcmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwcmVwYXJlZEFzKVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcykge1xuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9kZW5vcm1hbGl6ZXBhZ2VwYXRoLmRlbm9ybWFsaXplUGFnZVBhdGgpKHBhdGhuYW1lKSk7XG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09IFwiLzQwNFwiIHx8IGNsZWFuUGF0aG5hbWUgPT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYWdlKSAmJiAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGEoc291cmNlLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5leHRDb25maWcgPSB7XG4gICAgICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgbG9jYWxlczogb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICB9LFxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSClcbiAgICB9O1xuICAgIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJld3JpdGVcIik7XG4gICAgbGV0IHJld3JpdGVUYXJnZXQgPSByZXdyaXRlSGVhZGVyIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtbWF0Y2hlZC1wYXRoXCIpO1xuICAgIGNvbnN0IG1hdGNoZWRQYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1hdGNoZWQtcGF0aFwiKTtcbiAgICBpZiAobWF0Y2hlZFBhdGggJiYgIXJld3JpdGVUYXJnZXQgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiX19uZXh0X2RhdGFfY2F0Y2hhbGxcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiL19lcnJvclwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvNDA0XCIpKSB7XG4gICAgICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xuICAgICAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGg7XG4gICAgfVxuICAgIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZXdyaXRlVGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV3cml0ZVRhcmdldCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXdyaXRlVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lSW5mbyA9ICgwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGZzUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWVJbmZvLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKVxuICAgICAgICAgICAgXSkudGhlbigocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9XSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKGFzKSB8fCAhcmV3cml0ZUhlYWRlciAmJiBwYWdlcy5pbmNsdWRlcygoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnOiBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTID8gdW5kZWZpbmVkIDogbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRTb3VyY2UucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKGFzLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIChwYXRoKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gcmVzdWx0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpID8gcmVzb2x2ZUR5bmFtaWNSb3V0ZSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lLCBwYWdlcykgOiBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocmVzb2x2ZWRIcmVmKSkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIG1hdGNoZXMgfHwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJld3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0VGFyZ2V0ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZWRpcmVjdFwiKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWludGVybmFsXCIsXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxuICAgICAgICAgICAgICAgIG5ld1VybDogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdHlwZTogXCJuZXh0XCJcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBvcHRpb25zLmZldGNoRGF0YSgpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSBhd2FpdCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgICAgICAgICAganNvbjogZGF0YS5qc29uLFxuICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLnRleHQsXG4gICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyoqXG4gICAgICogVE9ETzogUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXG4gICAgICogRm9yIG5vdyB3ZSB3aWxsIG5vdCBjb25zaWRlciBtaWRkbGV3YXJlIGRhdGEgZXJyb3JzIHRvIGJlIGZhdGFsLlxuICAgICAqIG1heWJlIHdlIHNob3VsZCByZXZpc2l0IGluIHRoZSBmdXR1cmUuXG4gICAgICovIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwic2Nyb2xsUmVzdG9yYXRpb25cIiBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gXCJfX25leHRcIjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcbiAgICB9IGNhdGNoIChuKSB7fVxufSgpO1xuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKFwiU1NHX0RBVEFfTk9UX0ZPVU5EXCIpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgXCJ4LW5leHRqcy1kYXRhXCI6IFwiMVwiXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXJhbSkge1xuICAgIGxldCB7IGRhdGFIcmVmLCBpbmZsaWdodENhY2hlLCBpc1ByZWZldGNoLCBoYXNNaWRkbGV3YXJlLCBpc1NlcnZlclJlbmRlciwgcGFyc2VKU09OLCBwZXJzaXN0Q2FjaGUsIGlzQmFja2dyb3VuZCwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlIH0gPSBwYXJhbTtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdmFyIF9wYXJhbXNfbWV0aG9kO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+ZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiBcInByZWZldGNoXCJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xuICAgICAgICAgICAgICAgIFwieC1taWRkbGV3YXJlLXByZWZldGNoXCI6IFwiMVwiXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6IFwiR0VUXCJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgMzAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA4XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdHJ5VG9QYXJzZUFzSlNPTiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJ5VG9QYXJzZUFzSlNPTi5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNcIik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtY2FjaGVcIikgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy8gY2hyb21lXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIHx8IC8vIHNhZmFyaVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gICAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAgIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIlxuICAgIH0gOiB7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsLCByb3V0ZXIgfSA9IHBhcmFtO1xuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lXG4gICAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcbiAgICBpZiAodXJsID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBoYXJkIG5hdmlnYXRlIHRvIHRoZSBzYW1lIFVSTCBcIiArIHVybCArIFwiIFwiICsgbG9jYXRpb24uaHJlZik7XG4gICAgfVxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xufVxuY29uc3QgZ2V0Q2FuY2VsbGVkSGFuZGxlciA9IChwYXJhbSk9PntcbiAgICBsZXQgeyByb3V0ZSwgcm91dGVyIH0gPSBwYXJhbTtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCInICsgcm91dGUgKyAnXCInKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJwdXNoU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgKHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfYmZsKGFzLCByZXNvbHZlZEFzLCBsb2NhbGUsIHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsU3RhdGljID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbER5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3VyQXMgb2YgW1xuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXNcbiAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgIGlmIChjdXJBcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2ggPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkobmV3IFVSTChjdXJBcywgXCJodHRwOi8vblwiKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNOb1NsYXNoLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwodGhpcy5hc1BhdGgsIFwiaHR0cDovL25cIikucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9zLCBfdGhpc19fYmZsX3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc0JmbFN0YXRpYyA9IG1hdGNoZXNCZmxTdGF0aWMgfHwgISEoKF90aGlzX19iZmxfcyA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zLmNvbnRhaW5zKGFzTm9TbGFzaCkpIHx8ICEhKChfdGhpc19fYmZsX3MxID0gdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MxLmNvbnRhaW5zKGFzTm9TbGFzaExvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2hMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGFueSBzdWItcGF0aCBvZiBhcyBtYXRjaGVzIGEgZHluYW1pYyBmaWx0ZXIgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBoYXJkIG5hdmlnYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7ICFtYXRjaGVzQmZsRHluYW1pYyAmJiBpIDwgY3VyQXNQYXJ0cy5sZW5ndGggKyAxOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydCA9IGN1ckFzUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCAmJiAoKF90aGlzX19iZmxfZCA9IHRoaXMuX2JmbF9kKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9kLmNvbnRhaW5zKGN1cnJlbnRQYXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWVudCByb3V0ZXIgZmlsdGVyIGlzIG1hdGNoZWQgdGhlbiB3ZSB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNCZmxTdGF0aWMgfHwgbWF0Y2hlc0JmbER5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhcywgbG9jYWxlIHx8IHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWU7XG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybCkpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgIGNvbnN0IGlzUXVlcnlVcGRhdGluZyA9IG9wdGlvbnMuX2ggPT09IDE7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgdW5kZWZpbmVkLCBvcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNob3VsZFJlc29sdmVIcmVmID0gaXNRdWVyeVVwZGF0aW5nIHx8IG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmIHx8ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkodXJsKS5wYXRobmFtZSA9PT0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhcykucGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICAvLyBvciBhIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSB0aGlzLmlzUmVhZHkgIT09IHRydWU7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzU3NyID0gdGhpcy5pc1NzcjtcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHF1ZXJ5IHVwZGF0aW5nIGlzIHRyaWdnZXJlZCBpZ25vcmUgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLmNsYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZMb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IHRoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRBcy5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKSh1cmwpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkodXJsKSA6IHVybCwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc19sb2NhbGVzO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgICAgICAgICBpZiAoISgoX3RoaXNfbG9jYWxlcyA9IHRoaXMubG9jYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2xvY2FsZXMuaW5jbHVkZXMobmV4dFN0YXRlLmxvY2FsZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXJzZWRBcy5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gKDAsIF9kZXRlY3Rkb21haW5sb2NhbGUuZGV0ZWN0RG9tYWluTG9jYWxlKSh0aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiB0aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJodHRwXCIgKyAoZGV0ZWN0ZWREb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiICsgZGV0ZWN0ZWREb21haW4uZG9tYWluICsgKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoXCJcIiArIChuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgbmV4dFN0YXRlLmxvY2FsZSkgKyAoYXNOb0Jhc2VQYXRoID09PSBcIi9cIiA/IFwiXCIgOiBhc05vQmFzZVBhdGgpIHx8IFwiL1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhcInJvdXRlQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9IGZhbHNlLCBzY3JvbGwgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCByb3V0ZVByb3BzID0ge1xuICAgICAgICAgICAgc2hhbGxvd1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSAmJiB0aGlzLmNsYykge1xuICAgICAgICAgICAgaWYgKCFpc1Nzcikge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCB0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xjKCk7XG4gICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XG4gICAgICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiaGFzaENoYW5nZVN0YXJ0XCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQobmV4dFN0YXRlLCB0aGlzLmNvbXBvbmVudHNbbmV4dFN0YXRlLnJvdXRlXSwgbnVsbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiaGFzaENoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAgICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpLFxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwicmVwbGFjZVN0YXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgIGxldCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFzUGF0aG5hbWUgPSBhcy5zdGFydHNXaXRoKFwiL1wiKSAmJiAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICAvLyBpZiB3ZSBkZXRlY3RlZCB0aGUgcGF0aCBhcyBhcHAgcm91dGUgZHVyaW5nIHByZWZldGNoaW5nXG4gICAgICAgIC8vIHRyaWdnZXIgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICgoX3RoaXNfY29tcG9uZW50c19wYXRobmFtZSA9IHRoaXMuY29tcG9uZW50c1twYXRobmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lLl9fYXBwUm91dGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKHBhcnNlZEFzUGF0aG5hbWUgJiYgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiYgKCEoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpIHx8ICEoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKSk7XG4gICAgICAgIC8vIHdlIGRvbid0IGF0dGVtcHQgcmVzb2x2ZSBhc1BhdGggd2hlbiB3ZSBuZWVkIHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gbWlkZGxld2FyZSBhcyB0aGUgcmVzb2x2aW5nIHdpbGwgb2NjdXIgc2VydmVyLXNpZGVcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSAhb3B0aW9ucy5zaGFsbG93ICYmIGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlc29sdmVIcmVmICYmIHBhdGhuYW1lICE9PSBcIi9fZXJyb3JcIikge1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKCgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShhcykpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaHJlZjogXCInICsgdXJsICsgJ1wiIGFuZCBhczogXCInICsgYXMgKyAnXCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzJyArIFwiXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJlc29sdmVkQXMpLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBsZXQgcm91dGVNYXRjaCA9IGZhbHNlO1xuICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkocmVzb2x2ZWRBcyk7XG4gICAgICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKTtcbiAgICAgICAgICAgIHJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGUgPyAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSA6IHt9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgJiYgIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlwiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJJbnRlcnBvbGF0aW5nIGhyZWZcIiA6IFwiTWlzbWF0Y2hpbmcgYGFzYCBhbmQgYGhyZWZgXCIpICsgXCIgZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgXCIgKyAoXCJ0aGUgcGFyYW1zOiBcIiArIG1pc3NpbmdQYXJhbXMuam9pbihcIiwgXCIpICsgXCIgaW4gdGhlIGBocmVmYCdzIGBxdWVyeWBcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBcIlRoZSBwcm92aWRlZCBgaHJlZmAgKFwiICsgdXJsICsgXCIpIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzIChcIiArIG1pc3NpbmdQYXJhbXMuam9pbihcIiwgXCIpICsgXCIpIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gXCIgOiBcIlRoZSBwcm92aWRlZCBgYXNgIHZhbHVlIChcIiArIGFzUGF0aG5hbWUgKyBcIikgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIGBocmVmYCB2YWx1ZSAoXCIgKyByb3V0ZSArIFwiKS4gXCIpICsgKFwiUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9cIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZFwiIDogXCJpbmNvbXBhdGlibGUtaHJlZi1hc1wiKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZVN0YXJ0XCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Vycm9yUm91dGUgPSB0aGlzLnBhdGhuYW1lID09PSBcIi80MDRcIiB8fCB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcywgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcywgX3JvdXRlSW5mb19wcm9wcztcbiAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogaXNNaWRkbGV3YXJlTWF0Y2gsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGlzTWlkZGxld2FyZVJld3JpdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgXCJyZXNvbHZlZEFzXCIgaW4gcm91dGVJbmZvID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwicm91dGVcIiBpbiByb3V0ZUluZm8gJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJvdXRlSW5mby5yb3V0ZSB8fCByb3V0ZTtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghcm91dGVQcm9wcy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGVJbmZvLnF1ZXJ5IHx8IHt9LCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRQYXJzZWRQYXRobmFtZSA9ICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHBhcnNlZC5wYXRobmFtZSkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpIDogcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHBhdGhuYW1lICE9PSBjbGVhbmVkUGFyc2VkUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocm91dGVNYXRjaCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcXVlcnlba2V5XSA9PT0gcm91dGVNYXRjaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhlZEFzID0gIXJvdXRlUHJvcHMuc2hhbGxvdyAmJiByb3V0ZUluZm8ucmVzb2x2ZWRBcyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShuZXcgVVJMKGFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmV3cml0ZUFzID0gcHJlZml4ZWRBcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJld3JpdGVBcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVBcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShyZXdyaXRlQXMsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSBsb2NhbGVSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKHJvdXRlUmVnZXgpKG5ldyBVUkwocmV3cml0ZUFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJSb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBjdXJSb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZUluZm8gYnJpbmdzIGEgcmVkaXJlY3Qgd2Ugc2ltcGx5IGFwcGx5IGl0LlxuICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8udHlwZSA9PT0gXCJyZWRpcmVjdC1pbnRlcm5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlSW5mby5Db21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRzID0gW10uY29uY2F0KGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIoKSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XG4gICAgICAgICAgICAgICAgICAgICgwLCBfc2NyaXB0LmhhbmRsZUNsaWVudFNjcmlwdExvYWQpKHNjcmlwdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgIGlmICgocm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1ApICYmIHJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVzdGluYXRpb24gZnJvbSByZWRpcmVjdCB3aXRob3V0IGFkZGluZyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aChcIi9cIikgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RfQkFTRV9QQVRIICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWRIcmVmLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsLCBhczogbmV3QXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXJvdXRlSW5mby5wcm9wcy5fX05fUFJFVklFVztcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvNDA0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSBcIi9fZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vdEZvdW5kOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb3V0ZUluZm9fcm91dGU7XG4gICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKChfcm91dGVJbmZvX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlSW5mb19yb3V0ZSA6IHJvdXRlKTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9uc19zY3JvbGw7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAoX29wdGlvbnNfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfb3B0aW9uc19zY3JvbGwgOiAhaXNRdWVyeVVwZGF0aW5nICYmICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAgICAgICAvLyBxdWVyeSBwYXJhbWV0ZXJzLiBSb3V0ZSBjaGFuZ2VzIGhlcmUgbWlnaHQgYWRkIHRoZSBiYXNlUGF0aCB3aGVuIGl0XG4gICAgICAgICAgICAvLyB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50LiBUaGlzIGlzIGFsc28gd2h5IHRoaXMgYmxvY2sgaXMgYmVmb3JlIHRoZVxuICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIFVSTCkuXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzRXJyb3JSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxLCBfcm91dGVJbmZvX3Byb3BzMTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiBcIiArIHRoaXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgJiYgKChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMS5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMxID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wczEucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiYmVmb3JlSGlzdG9yeUNoYW5nZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBmb3IgcXVlcnkgdXBkYXRlcyB3ZSBjYW4gc2tpcCBpdCBpZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcbiAgICAgICAgICAgIGNvbnN0IGNhblNraXBVcGRhdGluZyA9IGlzUXVlcnlVcGRhdGluZyAmJiAhdXBjb21pbmdTY3JvbGxTdGF0ZSAmJiAhcmVhZHlTdGF0ZUNoYW5nZSAmJiAhbG9jYWxlQ2hhbmdlICYmICgwLCBfY29tcGFyZXN0YXRlcy5jb21wYXJlUm91dGVyU3RhdGVzKSh1cGNvbWluZ1JvdXRlclN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCByb3V0ZUluZm8uZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcm91dGVJbmZvLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC87XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LlwiICsgbWV0aG9kICsgXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJwdXNoU3RhdGVcIiB8fCAoMCwgX3V0aWxzLmdldFVSTCkoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXkgPSBtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgIFwiXCIsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIF9yb3V0ZWxvYWRlci5pc0Fzc2V0RXJyb3IpKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvX2Vycm9yXCIpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogXCIsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgXCJcIiksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJvdXRlSW5mbyhwYXJhbSkge1xuICAgICAgICBsZXQgeyByb3V0ZTogcmVxdWVzdGVkUm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMsIGxvY2FsZSwgaGFzTWlkZGxld2FyZSwgaXNQcmV2aWV3LCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsIGlzUXVlcnlVcGRhdGluZywgaXNNaWRkbGV3YXJlUmV3cml0ZSwgaXNOb3RGb3VuZCB9ID0gcGFyYW07XG4gICAgICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi8gbGV0IHJvdXRlID0gcmVxdWVzdGVkUm91dGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKFwiaW5pdGlhbFwiIGluIGV4aXN0aW5nSW5mbykgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiA/IGV4aXN0aW5nSW5mbyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcbiAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gXCIvNDA0XCIgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIHVuLW5lY2Vzc2FyeSBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGZhdGFsXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgZmFsbGJhY2sgcm91dGUgYW5kIHRoZSBwcm9wcyBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgICAgIC8vIGVmZmVjdHNcbiAgICAgICAgICAgIGlmIChkYXRhICYmIChwYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgfHwgcGF0aG5hbWUgPT09IFwiLzQwNFwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIiB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDEudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmVmZmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDIgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDIudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2FwaXJvdXRlLmlzQVBJUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJyArIHBhdGhuYW1lICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfcmVzcG9uc2UgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtc2tpcFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEZldGNoRGF0YSA9IHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQO1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXG4gICAgICAgICAgICAvLyB3ZSBjbGVhciB0aGUgY2FjaGUgdG8gZmV0Y2ggZnVsbCByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHdhc0JhaWxlZFByZWZldGNoICYmIChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tkYXRhLmRhdGFIcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGNhY2hlS2V5IH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgJiYgIXdhc0JhaWxlZFByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBkYXRhLmpzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUhyZWYgPSAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikgPyBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkID0gYXdhaXQgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogd2FzQmFpbGVkUHJlZmV0Y2ggPyB7fSA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZmV0Y2hlZC5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhyb3V0ZUluZm8uQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE9ubHkgYnVzdCB0aGUgZGF0YSBjYWNoZSBmb3IgU1NQIHJvdXRlcyBhbHRob3VnaFxuICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAgICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcbiAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uX19OX1NTUCAmJiBmZXRjaE5leHREYXRhUGFyYW1zLmRhdGFIcmVmICYmIGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgJiYgIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2JjXG4gICAgICAgICAgICAgICAgfSkpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KFwiI1wiLCAyKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdChcIiNcIiwgMik7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSBcIlwiXSA9IGFzLnNwbGl0KFwiI1wiLCAyKTtcbiAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+e1xuICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgICAgICBpZiAoaGFzaCA9PT0gXCJcIiB8fCBoYXNoID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cbiAgICAgICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaCk7XG4gICAgICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpO1xuICAgICAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgICAgICBpZEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHJhd0hhc2gpWzBdO1xuICAgICAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmx5SGFzaENoYW5nZTogdGhpcy5vbmx5QUhhc2hDaGFuZ2UoYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhc1BhdGggPT09IHZvaWQgMCkgYXNQYXRoID0gdXJsO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICgwLCBfaXNib3QuaXNCb3QpKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXG4gICAgICAgICAgICAvLyBwcmVmZXRjaGVzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgY29uc3QgdXJsUGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXNQYXRoO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiB0aGlzLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH0gPSBhd2FpdCAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCkpO1xuICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzUGF0aCwgdGhpcy5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhcnNlZC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXJzZWQucGF0aG5hbWUpKSgoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKGFzUGF0aCkucGF0aG5hbWUpIHx8IHt9KTtcbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09IFwic3RyaWN0XCIgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG9yaWdpbmFsUGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgd2FzIGEgcmV3cml0ZSB3ZSBhcHBseSB0aGUgZWZmZWN0cyBvZiB0aGUgcmV3cml0ZSBvbiB0aGVcbiAgICAgKiBjdXJyZW50IHBhcmFtZXRlcnMgZm9yIHRoZSBwcmVmZXRjaC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZXdyaXRlXCIpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IHRvIGFuIGV4dGVybmFsIGRlc3RpbmF0aW9uIHRoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIHRvIHByZWZldGNoIGNvbnRlbnQgYXMgaXQgd2lsbCBiZSB1bnVzZWQuXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuX2JmbChhc1BhdGgsIHJlc29sdmVkQXMsIG9wdGlvbnMubG9jYWxlLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3VybFBhdGhuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBfX2FwcFJvdXRlcjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTc2cgPyBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pID8gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fCBvcHRpb25zLnByaW9yaXR5ICYmICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFXG4gICAgICAgICAgICAgICAgfSkudGhlbigoKT0+ZmFsc2UpLmNhdGNoKCgpPT5mYWxzZSkgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyBcImxvYWRQYWdlXCIgOiBcInByZWZldGNoXCJdKHJvdXRlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEZsaWdodERhdGEoZGF0YUhyZWYpIHtcbiAgICAgICAgLy8gRG8gbm90IGNhY2hlIFJTQyBmbGlnaHQgcmVzcG9uc2Ugc2luY2UgaXQncyBub3QgYSBzdGF0aWMgcmVzb3VyY2VcbiAgICAgICAgcmV0dXJuIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHBhcnNlSlNPTjogZmFsc2UsXG4gICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZVxuICAgICAgICB9KS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB9XG4gICAgZ2V0IGFzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGU7XG4gICAgfVxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgaXNQcmV2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzLCBwYWdlTG9hZGVyLCBBcHAsIHdyYXBBcHAsIENvbXBvbmVudCwgZXJyLCBzdWJzY3JpcHRpb24sIGlzRmFsbGJhY2ssIGxvY2FsZSwgbG9jYWxlcywgZGVmYXVsdExvY2FsZSwgZG9tYWluTG9jYWxlcywgaXNQcmV2aWV3IH0pe1xuICAgICAgICAvLyBTZXJ2ZXIgRGF0YSBDYWNoZSAoZnVsbCBkYXRhIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNkYyA9IHt9O1xuICAgICAgICAvLyBTZXJ2ZXIgQmFja2dyb3VuZCBDYWNoZSAoSEVBRCByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zYmMgPSB7fTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2tleSA9IGNyZWF0ZUtleSgpO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscy5nZXRVUkwpKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIHBvcHN0YXRlZXZlbnQgd2hlbiByZW9wZW5pbmcgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGtleSB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoXCJyZXBsYWNlU3RhdGVcIiwgdXJsLCBhcywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdmFsdWUgbm90IGV4cG9zZWQgb24gdHlwZXNcbiAgICAgICAgICAgICAgICBfaDogMFxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgICAgIGlmIChwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgY29uc3QgeyBCbG9vbUZpbHRlciB9ID0gcmVxdWlyZShcIi4uLy4uL2xpYi9ibG9vbS1maWx0ZXJcIik7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVI7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSO1xuICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEubnVtSGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MgPSBuZXcgQmxvb21GaWx0ZXIoc3RhdGljRmlsdGVyRGF0YS5udW1JdGVtcywgc3RhdGljRmlsdGVyRGF0YS5lcnJvclJhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9zLmltcG9ydChzdGF0aWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeW5hbWljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogZHluYW1pY0ZpbHRlckRhdGEubnVtSGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QgPSBuZXcgQmxvb21GaWx0ZXIoZHluYW1pY0ZpbHRlckRhdGEubnVtSXRlbXMsIGR5bmFtaWNGaWx0ZXJEYXRhLmVycm9yUmF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QuaW1wb3J0KGR5bmFtaWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgICAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHM7XG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID0gKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydDtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgXCJcIjtcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uaXNFeHBlcmltZW50YWxDb21waWxlIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISEoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgICAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWFzLnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc1BhdGggPSAoMCwgX3V0aWxzLmdldFVSTCkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoXG4gICAgICAgICAgICAgICAgfSkudGhlbigobWF0Y2hlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhcyAhPT0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgbWF0Y2hlcyA/IGFzUGF0aCA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksIGFzUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQuZGVmYXVsdCkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImRlZmF1bHQiLCJtYXRjaGVzTWlkZGxld2FyZSIsImNyZWF0ZUtleSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJfcm91dGVsb2FkZXIiLCJfc2NyaXB0IiwiX2lzZXJyb3IiLCJfIiwiX2Rlbm9ybWFsaXplcGFnZXBhdGgiLCJfbm9ybWFsaXplbG9jYWxlcGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzZHluYW1pYyIsIl9wYXJzZXJlbGF0aXZldXJsIiwiX3Jlc29sdmVyZXdyaXRlcyIsIl9yb3V0ZW1hdGNoZXIiLCJfcm91dGVyZWdleCIsIl9mb3JtYXR1cmwiLCJfZGV0ZWN0ZG9tYWlubG9jYWxlIiwiX3BhcnNlcGF0aCIsIl9hZGRsb2NhbGUiLCJfcmVtb3ZlbG9jYWxlIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2FkZGJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX3Jlc29sdmVocmVmIiwiX2lzYXBpcm91dGUiLCJfZ2V0bmV4dHBhdGhuYW1laW5mbyIsIl9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvIiwiX2NvbXBhcmVzdGF0ZXMiLCJfaXNsb2NhbHVybCIsIl9pc2JvdCIsIl9vbWl0IiwiX2ludGVycG9sYXRlYXMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImFzc2lnbiIsIkVycm9yIiwiY2FuY2VsbGVkIiwib3B0aW9ucyIsIm1hdGNoZXJzIiwiYXNQYXRobmFtZSIsImNsZWFuZWRBcyIsImFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyb3V0ZXIiLCJwYWdlTG9hZGVyIiwiZ2V0TWlkZGxld2FyZSIsInBhcnNlUGF0aCIsImFzUGF0aCIsInBhdGhuYW1lIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVIcmVmIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJwYXJhbSIsIl9fcmV3cml0ZXMiLCJyZXdyaXRlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXJzZWRTb3VyY2UiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwidW5kZWZpbmVkIiwicmVzdWx0IiwicXVlcnkiLCJwYXRoIiwibWF0Y2hlZFBhZ2UiLCJwYXJzZWRBcyIsInJlc29sdmVkUGF0aG5hbWUiLCJtYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwidHlwZSIsInNyYyIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJkZWZhdWx0TG9jYWxlIiwiYnVpbGRJZCIsImRlc3RpbmF0aW9uIiwiaGFzaCIsInJlZGlyZWN0VGFyZ2V0IiwibmV3QXMiLCJuZXdVcmwiLCJ3aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJkYXRhIiwiZWZmZWN0IiwiZSIsImZldGNoRGF0YSIsImRhdGFIcmVmIiwianNvbiIsInRleHQiLCJjYWNoZUtleSIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwib2siLCJzdGF0dXMiLCJ0cnlUb1BhcnNlQXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJmZXRjaE5leHREYXRhIiwiaW5mbGlnaHRDYWNoZSIsImlzUHJlZmV0Y2giLCJoYXNNaWRkbGV3YXJlIiwiaXNTZXJ2ZXJSZW5kZXIiLCJwYXJzZUpTT04iLCJwZXJzaXN0Q2FjaGUiLCJpc0JhY2tncm91bmQiLCJ1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUiLCJVUkwiLCJsb2NhdGlvbiIsImhyZWYiLCJfcGFyYW1zX21ldGhvZCIsImdldERhdGEiLCJwYXJhbXMiLCJwdXJwb3NlIiwiX3RyeVRvUGFyc2VBc0pTT04iLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiY2F0Y2giLCJlcnIiLCJtZXNzYWdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsImluaXRpYWxQcm9wcyIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInNkYyIsInNiYyIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50IiwiX2tleSIsIm9uUG9wU3RhdGUiLCJzdGF0ZSIsImNoYW5nZVN0YXRlIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJnZXRVUkwiLCJfX05BIiwicmVsb2FkIiwiX19OIiwiZm9yY2VkU2Nyb2xsIiwia2V5Iiwic3RyaW5naWZ5IiwieCIsInNlbGYiLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEl0ZW0iLCJpc1NzciIsIl9icHMiLCJjaGFuZ2UiLCJzaGFsbG93IiwiX3NoYWxsb3ciLCJfaCIsImNvbXBvbmVudHMiLCJpbml0aWFsIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsInN0eWxlU2hlZXRzIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQiLCJCbG9vbUZpbHRlciIsInN0YXRpY0ZpbHRlckRhdGEiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiIsImR5bmFtaWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVIiLCJudW1IYXNoZXMiLCJfYmZsX3MiLCJudW1JdGVtcyIsImVycm9yUmF0ZSIsImltcG9ydCIsIl9iZmxfZCIsImV2ZW50cyIsImF1dG9FeHBvcnREeW5hbWljIiwiX19ORVhUX0RBVEFfXyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwic3ViIiwiX3dyYXBBcHAiLCJpc0xvY2FsZURvbWFpbiIsImlzUmVhZHkiLCJnc3NwIiwiZ2lwIiwiaXNFeHBlcmltZW50YWxDb21waWxlIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImRldGVjdERvbWFpbkxvY2FsZSIsImhvc3RuYW1lIiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJiYWNrIiwiZm9yd2FyZCIsInB1c2giLCJyZXBsYWNlIiwiX2JmbCIsInNraXBOYXZpZ2F0ZSIsIm1hdGNoZXNCZmxTdGF0aWMiLCJtYXRjaGVzQmZsRHluYW1pYyIsImN1ckFzIiwiYXNOb1NsYXNoIiwiYXNOb1NsYXNoTG9jYWxlIiwiX3RoaXNfX2JmbF9zIiwiX3RoaXNfX2JmbF9zMSIsIm5vcm1hbGl6ZWRBUyIsImN1ckFzUGFydHMiLCJpIiwiX3RoaXNfX2JmbF9kIiwiY3VycmVudFBhcnQiLCJjb250YWlucyIsInNwbGl0Iiwiam9pbiIsIl90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUiLCJpc1F1ZXJ5VXBkYXRpbmciLCJzaG91bGRSZXNvbHZlSHJlZiIsIm5leHRTdGF0ZSIsInJlYWR5U3RhdGVDaGFuZ2UiLCJwcmV2TG9jYWxlIiwibG9jYWxlUGF0aFJlc3VsdCIsImRpZE5hdmlnYXRlIiwiX3RoaXNfbG9jYWxlcyIsImRldGVjdGVkRG9tYWluIiwiYXNOb0Jhc2VQYXRoIiwic2Nyb2xsIiwicm91dGVQcm9wcyIsImxvY2FsZUNoYW5nZSIsInBhcnNlZCIsInBhcnNlZEFzUGF0aG5hbWUiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsIm1pc3NpbmdQYXJhbXMiLCJpc0Vycm9yUm91dGUiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMiLCJfcm91dGVJbmZvX3Byb3BzIiwicm91dGVJbmZvIiwiY2xlYW5lZFBhcnNlZFBhdGhuYW1lIiwicHJlZml4ZWRBcyIsInJld3JpdGVBcyIsImxvY2FsZVJlc3VsdCIsImN1clJvdXRlTWF0Y2giLCJjb21wb25lbnQiLCJzY3JpcHRzIiwicGFyc2VkSHJlZiIsIm5vdEZvdW5kUm91dGUiLCJfcm91dGVJbmZvX3JvdXRlIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsIl9vcHRpb25zX3Njcm9sbCIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsInVwY29taW5nUm91dGVyU3RhdGUiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSIsIl9yb3V0ZUluZm9fcHJvcHMxIiwiY2FuU2tpcFVwZGF0aW5nIiwiaGFzaFJlZ2V4IiwiaXNMb2NhbFVSTCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwiaHR0cCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiX2luRmxpZ2h0Um91dGUiLCJlbWl0IiwicmVtb3ZlTG9jYWxlIiwib25seUFIYXNoQ2hhbmdlIiwic2Nyb2xsVG9IYXNoIiwic2V0IiwidXJsSXNOZXciLCJfX2FwcFJvdXRlciIsInAiLCJleHRlcm5hbERlc3QiLCJpbnRlcnBvbGF0ZUFzIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsIm9wdGlvbmFsIiwiY29uc29sZSIsIndhcm4iLCJvbWl0IiwiZ2V0Um91dGVJbmZvIiwiZm9yRWFjaCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsImNvbmNhdCIsInNjcmlwdCIsImhhbmRsZUNsaWVudFNjcmlwdExvYWQiLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwiX19OX1BSRVZJRVciLCJmZXRjaENvbXBvbmVudCIsImlzTm90Rm91bmQiLCJzdGF0dXNDb2RlIiwiY29tcGFyZVJvdXRlclN0YXRlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwibG9hZEVycm9yRmFpbCIsImdpcEVyciIsInJvdXRlSW5mb0VyciIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsInJlcXVlc3RlZFJvdXRlIiwiX2RhdGFfZWZmZWN0IiwiX2RhdGFfZWZmZWN0MSIsIl9kYXRhX2VmZmVjdDIiLCJfZGF0YV9yZXNwb25zZSIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJyZXNvbHZlZFJvdXRlIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwid2FzQmFpbGVkUHJlZmV0Y2giLCJzaG91bGRGZXRjaERhdGEiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwiaXNBUElSb3V0ZSIsInJlcyIsIm1vZCIsIl9nZXREYXRhIiwiZmV0Y2hlZCIsImdldFByb3BlckVycm9yIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJyYXdIYXNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsIm9ubHlIYXNoQ2hhbmdlIiwicHJlZmV0Y2giLCJ1cmxQYXRobmFtZSIsIm9yaWdpbmFsUGF0aG5hbWUiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIl9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsIl9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRSIsImNvbXBvbmVudFJlc3VsdCIsImxvYWRQYWdlIiwiZm4iLCJfZ2V0RmxpZ2h0RGF0YSIsImN0eCIsIkFwcFRyZWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});